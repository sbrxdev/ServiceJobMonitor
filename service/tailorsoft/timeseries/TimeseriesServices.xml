<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">
    <!--   process data point  -->
    <service verb="process" noun="JobRunResults" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="jobRunId" required="true"/>
            <parameter name="endTime" required="true"/>
            <parameter name="jobName" required="true"/>
            <parameter name="results" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="value"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="tailorsoft.timeseries.Monitor" value-field="monitor" cache="true">
                <field-map field-name="jobName"/>
            </entity-find-one>
            <if condition="!monitor">
                <!-- No monitor found, abort -->
                <return/>
            </if>
            <set field="jsonResults" from="new groovy.json.JsonSlurper().parseText(results)"/>

            <!-- TODO, switch to JsonPath: https://github.com/json-path/JsonPath -->
            <set field="pathParts" from="monitor.valuePath.split('\\.')"/>
            <iterate list="pathParts" entry="part">
                <if condition="!jsonResults[part]">
                    <return error="true" message="No value found in ${results} at ${monitor.valuePath}"/>
                </if>
                <set field="jsonResults" from="jsonResults[part]"/>
            </iterate>

            <set field="doubleValue" from="Float.parseFloat(jsonResults.toString())"/>
            <if condition="doubleValue == null">
                <return error="true" message="No double value found at path: ${monitor.valuePath} in ${results} "/>
            </if>

            <!-- store in elasticsearch -->
            <service-call name="tailorsoft.timeseries.TimeseriesServices.save#Datapoint"
                          in-map="[date:endTime, value:doubleValue, indexName:monitor.indexName]"/>

            <if condition="monitor.algorithmEnumId == 'ALGO_BOUNDS'">
                <service-call
                        name="tailorsoft.timeseries.TimeseriesServices.process#DatapointBounds"
                        in-map="[indexName:monitor.indexName, value:doubleValue, date:endDate, jobName:jobName ]"/>
            </if>
        </actions>
    </service>

    <!-- Save date point in elasticsearh   -->
    <service verb="save" noun="Datapoint" authenticate="anonymous-view">
        <in-parameters>
            <parameter name="indexName" required="true"/>
            <parameter name="date" required="true"/>
            <parameter name="value" required="true"/>
        </in-parameters>
        <actions>
            <set field="json" from="[:]"/>
            <script>
                <![CDATA[
                import org.elasticsearch.action.get.MultiGetItemResponse
                import org.elasticsearch.action.get.MultiGetRequestBuilder
                import org.elasticsearch.action.search.SearchRequest
                import org.elasticsearch.action.search.SearchRequestBuilder
                import org.elasticsearch.index.query.QueryBuilder
                import org.elasticsearch.index.query.QueryBuilders
                import org.elasticsearch.search.SearchHit
                import org.elasticsearch.search.SearchHits
                import org.elasticsearch.search.sort.SortOrder
                import org.elasticsearch.client.Client
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil
                import org.moqui.elasticsearch.EsClient

                //create the ES client
                ExecutionContext ec = context.ec
                EsClient esClient = ec.getTool("ElasticSearch", EsClient.class)

                //use the default timestamp value
                // @TODO: Parse date from endTime service
                json.put("@timestamp", new Date())
                // value from the service
                json.put("value", value)

                try {
                    Client client = esClient.getClient();

                    if (!esClient.checkIndexExists(indexName)) {
                        client
                                .admin()
                                .indices()
                                .prepareCreate(indexName)
                                .addMapping("_doc", "@timestamp", "type=date", "value", "type=float")
                                .get()

                        logger.info("\n ====== ElasticSearch index created: ${indexName}")
                    }

                    client.prepareIndex(indexName, "_doc").setSource(json).get()
                } finally {

                }
                ]]>
                    </script>
            <log message="\n ====== ElasticSearch Saved:[ ${indexName}, ${date}, ${value} ]"/>
        </actions>
    </service>

    <!--  search Elasticsearch data  -->
    <service verb="process" noun="DatapointBounds" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="jobName"/>
            <parameter name="indexName"/>
            <parameter name="value"/>
        </in-parameters>
        <out-parameters>
            <parameter name="value"/>
        </out-parameters>
        <actions>
            <log message="\n ======= bounds ${indexName}, ${value}, ${jobName}, ${context} "/>
            <set field="messageData" from="[:]"/>
            <entity-find-one entity-name="tailorsoft.timeseries.MonitorBounds" value-field="monitorBounds" cache="true">
                <field-map field-name="jobName"/>
            </entity-find-one>

            <log message="\n ======= entity bounds: ${monitorBounds}"/>

            <script>
                <![CDATA[
                import org.elasticsearch.action.get.MultiGetItemResponse
                import org.elasticsearch.action.get.MultiGetRequestBuilder
                import org.elasticsearch.action.search.SearchRequest
                import org.elasticsearch.action.search.SearchRequestBuilder
                import org.elasticsearch.index.query.QueryBuilder
                import org.elasticsearch.index.query.QueryBuilders
                import org.elasticsearch.search.SearchHit
                import org.elasticsearch.search.SearchHits
                import org.elasticsearch.search.sort.SortBuilder
                import org.elasticsearch.search.sort.SortOrder
                import org.elasticsearch.client.Client
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil
                import org.moqui.elasticsearch.EsClient
                import org.elasticsearch.action.search.SearchResponse
                import org.elasticsearch.action.search.SearchType;
                import org.elasticsearch.index.query.QueryBuilders.*;
                import org.elasticsearch.search.sort.SortBuilders
                import org.elasticsearch.search.sort.SortOrder

                import javax.naming.directory.SearchControls

                //create the ES client
                ExecutionContext ec = context.ec
                EsClient esClient = ec.getTool("ElasticSearch", EsClient.class)

                try {
                    Client client = esClient.getClient();

                    int alertCount = Integer.parseInt(monitorBounds.count.toString())

                    SearchResponse response = client
                            .prepareSearch((String) indexName)
                            .addSort("@timestamp", SortOrder.DESC)
                            .setSize(alertCount + 1)
                            .get()

                    logger.info("\n ======== ES results")
                    logger.info(response.toString())

                    // hits from elasticsearch
                    SearchHits hits = response.getHits()

                    Float upperBound = Float.parseFloat(monitorBounds.upper.toString())
                    Float lowerBound = Float.parseFloat(monitorBounds.lower.toString())
                    int boundsCount = Integer.parseInt(monitorBounds.count.toString());

                    Map firstPoint = hits[hits.size() - 1].getSourceAsMap()
                    Float firstPointValue = Float.parseFloat(firstPoint.value.toString());
                    Map currentPoint = hits[0].getSourceAsMap();
                    Float currentPointValue = Float.parseFloat(currentPoint.value.toString());
                    int size = hits.size();

                    if (
                    size > boundsCount &&
                            currentPointValue >= upperBound &&
                            firstPointValue < upperBound
                    ) {
                        /*
                            the last item in the list is the first in chronological order
                            the last element has already been evaluated so it is omitted
                            size - 1 - 1 = size - 2
                        */
                        Boolean allPointValid = true;

                        for (int i = hits.size() - 2; i >= 0; i--) {
                            Map hit = hits[i].getSourceAsMap()
                            Float value = Float.parseFloat(hit.value.toString())

                            if (value < upperBound) {
                                allPointValid = false;
                            }
                        }

                        if(allPointValid){
                            // @TODO: send alerts here
                        }

                        logger.info('====== all point valid?')
                        logger.info(allPointValid)
                    } else {
                        logger.info('============= no point valid')
                        logger.info(firstPoint.toString())
                        logger.info(currentPoint.toString())
                        logger.info(size.toString())
                        logger.info(monitorBounds.toString())

                    }

                    /* for (int i = hits.size() - 1; i >= 0; i--) {
                         Map hit = hits[i].getSourceAsMap()
                         Float value = Float.parseFloat(hit.value)


                         logger.info(hit.toString())

                         if (i == 0) {
                             if (value < upperBound && value >= lowerBound) {
                                 firstIsNormal = true;
                             }
                         } else {
                             if (value > upperBound || value < lowerBound) {
                                 outBoundsCount = outBoundsCount + 1
                             }
                         }
                     }

                     if (firstIsNormal && outBoundsCount == alertCount) {
                         // @todo: mark as alert
                         logger.info('alert here')
                         messageData.put('jobId', jobId)
                         messageData.put('jobName', jobName)

                         value = ec
                                 .makeNotificationMessage()
                                 .topic("TestNotification")
                                 .type("danger")
                                 .title("Alert message")
                                 .message(messageData)
                                 .userGroupId("ALL_USERS")
                                 .send()
                                 .getNotificationMessageId()
                     }*/


                } finally {
                    // TODO close client?
                }
                ]]>
            </script>
        </actions>
    </service>

    <!-- Get charts info   -->
    <service verb="get" noun="Monitors" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="fromDate"/>
            <parameter name="thruDate"/>
        </in-parameters>
        <out-parameters>
            <parameter name="value"/>
        </out-parameters>
        <actions>
            <set field="res" from="[]"/>
            <!-- TODO restrict by Org -->
            <entity-find entity-name="tailorsoft.timeseries.Monitor" list="monitorList"/>
            <script>
                 <![CDATA[
                import org.apache.lucene.util.QueryBuilder
                import org.elasticsearch.index.query.QueryBuilders
                import org.elasticsearch.search.SearchHit
                import org.elasticsearch.search.SearchHits
                import org.elasticsearch.search.sort.SortOrder
                import org.elasticsearch.client.Client
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil
                import org.moqui.elasticsearch.EsClient
                import org.elasticsearch.action.search.SearchResponse
                import groovy.json.JsonOutput
                import java.text.SimpleDateFormat;

                //create the ES client
                ExecutionContext ec = context.ec
                EsClient esClient = ec.getTool("ElasticSearch", EsClient.class)
                Client client = esClient.getClient();

                logger.info("=================")
                logger.info(fromDate)
                logger.info(thruDate)

                SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");


                Date fromDateObject = formatter.parse(fromDate)
                Date thruDateObject = formatter.parse(thruDate)


                for (int i = 0; i < monitorList.size(); i++) {
                    String indexName = monitorList[i].indexName
                    String jobName = monitorList[i].jobName

                    Map r = ec.entity.find("tailorsoft.timeseries.MonitorBounds").condition("jobName", jobName).one()

                    List hitsList = []

                    SearchHits hits = client
                            .prepareSearch((String) indexName)
                            .setQuery(QueryBuilders.rangeQuery("@timestamp").from(fromDate).to(thruDate))
                            .addSort("@timestamp", SortOrder.DESC)
                            .setSize(9999)
                            .get()
                            .getHits()

                    for (int x = 0; x < hits.size(); x++) {
                        hitsList.push(hits[x].getSourceAsMap())
                    }

                    res.push([indexName: indexName, data: hitsList, bounds: r, fromDate: fromDateObject, thruDate: thruDateObject])
                }

                value = res
                ]]>
            </script>
        </actions>
    </service>

    <service verb="test" noun="Test" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="jobId"/>
            <parameter name="jobName"/>
        </in-parameters>
        <out-parameters>
            <parameter name="value"/>
        </out-parameters>

        <actions>
            <log message="========== test service "/>
            <script>

                <![CDATA[
                import org.moqui.context.ExecutionContext

                Map<String, Object> json = [:]
                ExecutionContext ec = context.ec

                json.put('jobId', jobId)
                json.put('jobName', jobName)

                value = ec.makeNotificationMessage().topic("TestNotification").type("danger").title("Test notification message")
                        .message(json).userGroupId("ALL_USERS").send().getNotificationMessageId()


                logger.info('no return')
                ]]>
            </script>
        </actions>
    </service>
</services>
